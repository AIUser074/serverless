<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공동 투자 프로젝트 | UI 프로토타입</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- CSS 코드 시작 --- */
        :root {
            --primary-color: #4a69bd;
            --secondary-color: #1e3799;
            --background-color: #f1f2f6;
            --text-color: #2f3542;
            --ai-message-bg: #e4f1fe;
            --system-message-color: #7f8c8d;
            --success-color: #2980b9;
            --danger-color: #c0392b;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .game-wrapper {
            width: 100%;
            max-width: 1000px;
            background: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            box-sizing: border-box;
        }

        header h1 {
            text-align: center;
            color: var(--secondary-color);
            margin-top: 0;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        .score-board span { margin-left: 20px; }
        .score-board strong { color: var(--primary-color); font-size: 1.1em; }

        .main-content {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }

        .chat-container, .action-container {
            flex: 1;
            border: 1px solid #dfe4ea;
            border-radius: 10px;
            padding: 20px;
        }

        h3 {
            color: var(--secondary-color);
            margin-top: 0;
            border-bottom: 2px solid #dfe4ea;
            padding-bottom: 10px;
        }

        .chat-log {
            height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }
        .chat-log p {
            margin: 0 0 15px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 85%;
            word-wrap: break-word;
        }
        .chat-log .system {
            font-style: italic;
            text-align: center;
            color: var(--system-message-color);
            background: none;
        }
        .chat-log .ai {
            background: var(--ai-message-bg);
            border-bottom-left-radius: 0;
            align-self: flex-start;
        }

        .action-container { text-align: center; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin: 40px 0; }
        .slider { flex-grow: 1; -webkit-appearance: none; height: 10px; background: #d3d3d3; border-radius: 5px; outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 25px; height: 25px; background: var(--primary-color); cursor: pointer; border-radius: 50%; }
        .slider-label { font-weight: bold; color: var(--secondary-color); }
        .slider-value-display { font-size: 1.5em; font-weight: 700; color: var(--text-color); margin-bottom: 40px; }
        .slider-value-display strong { color: var(--primary-color); font-size: 1.8em; }

        #decide-button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: 700;
            color: #fff;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #decide-button:hover { background-color: var(--secondary-color); }
        #decide-button:disabled { background-color: #a4b0be; cursor: not-allowed; }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex; /* 기본값을 flex로 변경 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            width: 90%;
            max-width: 500px; /* 최종 결과창을 위해 너비 약간 확장 */
        }
        #result-text { font-size: 1.2em; line-height: 1.8; }
        .text-success { color: var(--success-color); font-weight: 700; }
        .text-danger { color: var(--danger-color); font-weight: 700; }

        #ranking-board { margin-top: 20px; }
        #ranking-board h3 { color: var(--secondary-color); }
        #ranking-board ol { list-style-position: inside; padding: 0; text-align: left; }
        #ranking-board li { padding: 8px; border-bottom: 1px solid #eee; }
        #ranking-board li.player-rank { background-color: var(--ai-message-bg); font-weight: 700; border-radius: 4px;}

        #next-round-button, #start-game-button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white; border: none; border-radius: 5px;
        }
        .persona-selection { display: flex; gap: 15px; justify-content: center; margin-top: 15px; }
        .persona-selection button { flex: 1; }
        .chat-input-container { display: flex; margin-top: 15px; }
        #chat-input { flex-grow: 1; border: 1px solid #dfe4ea; border-right: none; padding: 10px; border-radius: 8px 0 0 8px; }
        #chat-input:focus { outline: none; border-color: var(--primary-color); }
        #send-chat-button { padding: 0 15px; border: 1px solid var(--primary-color); background-color: var(--primary-color); color: white; font-weight: 500; cursor: pointer; border-radius: 0 8px 8px 0; }
        #send-chat-button:disabled { background-color: #a4b0be; border-color: #a4b0be; cursor: not-allowed;}
        /* --- CSS 코드 끝 --- */
    </style>
</head>
<body>
    <!-- 튜토리얼 모달 -->
    <div id="tutorial-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>AI 파트너 선택</h2>
            <p>이번 게임에서 협상할 AI의 성격을 선택해주세요.</p>
            <div class="persona-selection">
                <button id="select-logical">🤖 논리적 분석가</button>
                <button id="select-emotional">❤️ 감정적 파트너</button>
                <button id="select-competitive">🏆 냉철한 승부사</button>
                <button id="select-titfortat">🤝 원칙주의 협력가</button>
            </div>
            <hr style="margin: 20px 0;">
            <h2>게임 방법 설명</h2>
            <div style="text-align: left; margin-top: 20px;">
                <p><strong>목표:</strong> 5라운드 동안 AI 파트너와 협력하여 가장 높은 점수를 획득하세요.</p>
                <ul>
                    <li>매 라운드 10포인트의 기본 자본이 주어집니다.</li>
                    <li>AI와 협상하여 0~10 사이의 포인트를 '공동 펀드'에 투자합니다.</li>
                    <li><strong>나머지 포인트는 개인 금고에 보관됩니다.</strong></li>
                    <li>라운드 종료 시, 공동 펀드의 총액은 <strong>1.5배</strong>가 되어 모두에게 똑같이 분배됩니다.</li>
                    <li><strong>나의 최종 점수 = (개인 금고 포인트) + (분배금)</strong></li>
                    <li>60초 안에 결정하지 못하면, 중간값인 5포인트가 자동으로 투자됩니다.</li>
                </ul>
            </div>
            <button id="start-game-button">게임 시작!</button>
        </div>
    </div>

    <div class="game-wrapper">
        <header>
            <h1>공동 투자 프로젝트</h1>
            <div class="status-bar">
                <div id="round-display">라운드: 1 / 5</div>
                <div id="timer-display">남은 시간: 60초</div>
                <div class="score-board">
                    <span>나의 총점: <strong id="my-score">0</strong></span>
                    <span>상대 총점: <strong id="opponent-score">0</strong></span>
                </div>
            </div>
        </header>

        <main class="main-content">
            <div class="chat-container">
                <h3>🤖 AI 파트너 '코디(CoDI)'와의 협상</h3>
                <div class="chat-log" id="chat-log">
                    <p class="system">게임이 시작되었습니다. 파트너와 협상하여 최선의 결정을 내리세요.</p>
                    <!-- JavaScript가 AI 메시지를 여기에 추가합니다 -->
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chat-input" placeholder="AI에게 메시지 보내기... (3회 남음)">
                    <button id="send-chat-button">전송</button>
                </div>
            </div>
            <div class="action-container">
                <h3>나의 결정</h3>
                <p>이번 라운드에 얼마를 '공동 펀드'에 투자하시겠습니까?</p>
                <div class="slider-container">
                    <span class="slider-label">0</span>
                    <input type="range" min="0" max="10" value="5" class="slider" id="investment-slider">
                    <span class="slider-label">10</span>
                </div>
                <div class="slider-value-display">
                    투자금: <strong id="slider-value">5</strong> 포인트
                </div>
                <button id="decide-button">결정하기</button>
            </div>
        </main>
    </div>

    <!-- 라운드 결과 팝업 모달 -->
    <div id="result-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">라운드 1 결과</h2>
            <div id="result-text">
                <!-- JavaScript가 결과를 여기에 채웁니다 -->
            </div>
            <div id="ranking-board">
                 <!-- JavaScript가 랭킹 보드를 여기에 채웁니다 -->
            </div>
            <button id="next-round-button">다음 라운드로</button>
        </div>
    </div>

     <script src="https://apis.google.com/js/api.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/jsrsasign@10.8.6/lib/jsrsasign-all-min.js"></script>
     <script type="module">
         // --- SDK Import ---
         import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
 
            // --- DOM 요소 가져오기 ---
            const slider = document.getElementById('investment-slider');
            const sliderValue = document.getElementById('slider-value');
            const decideButton = document.getElementById('decide-button');
            const chatLog = document.getElementById('chat-log');
            const roundDisplay = document.getElementById('round-display');
            const myScoreDisplay = document.getElementById('my-score');
            const opponentScoreDisplay = document.getElementById('opponent-score');
            const resultModal = document.getElementById('result-modal');
            const modalTitle = document.getElementById('modal-title');
            const resultText = document.getElementById('result-text');
            const nextRoundButton = document.getElementById('next-round-button');
         const timerDisplay = document.getElementById('timer-display');
         const tutorialModal = document.getElementById('tutorial-modal');
         const selectLogicalButton = document.getElementById('select-logical');
         const selectEmotionalButton = document.getElementById('select-emotional');
         const selectCompetitiveButton = document.getElementById('select-competitive');
         const selectTitfortatButton = document.getElementById('select-titfortat');
         const rankingBoard = document.getElementById('ranking-board');
         const chatInput = document.getElementById('chat-input');
         const sendChatButton = document.getElementById('send-chat-button');
 
         // --- 게임 및 AI 상태 변수 ---
         let GEMINI_API_KEY = 'AIzaSyCbToGyb5R0-76OatFH44bblP3TsmWXgx0';
         let playerName = 'Player';
         let playerId = ''; // 고유 ID 변수 (이제 해시만 저장)
            let currentRound = 1;
            let myTotalScore = 0;
            let opponentTotalScore = 0;
         const MAX_ROUNDS = 5;
         let timer = 60;
         let timerInterval;
         
         let aiPersona = {};
         let gameHistory = []; // { round, myInvestment, opponentInvestment }
         let chat; // SDK Chat Session
         let chatTurn = 0;
         const MAX_CHAT_TURNS = 3;
         let aiDecision = 5; // AI의 잠정적인 결정
         let chatHistory = []; // SDK 호환 멀티턴 히스토리 {role, parts:[{text}]}
 
         // --- [추가] Google Sheets 연동 정보 ---
        const GOOGLE_SHEET_ID = '1ZmCRt3oeHHN8xQiWhl8l70m7PifFgEI8Yr2t1xtyTFM';
        // 🚨 보안 경고: 아래 서비스 계정 키는 클라이언트 코드에 절대 노출해서는 안 됩니다.
        // 이것은 프로토타입 목적으로만 사용되며, 실제 환경에서는 서버에서 처리해야 합니다.
        const GOOGLE_SERVICE_ACCOUNT_KEY = {
            "type": "service_account",
            "project_id": "gen-lang-client-0848963700",
            "private_key_id": "f3a6cfc46c72f7896121673f840e698056a830c0",
            "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC0OCU6gFtKVuIx\n8P4Mmr8JgLIPSy76nlo/DfXa5vatqaM51vGFcLj9joJGXrrxLon4Ww8WZ1wgpcS0\nKydtwBdR+zppPP5BjIWiwRYBfeLgGEDXsluMwHshbn5H9KZKSZ7GmSMSp4ITw+bY\n7Cvxfz4P4OK4JZ3LUzhN10K52086O+ri9eOLbimWm3EDr6K8XUAXBOGWcxXz0S9W\nGBjljBMjemWtloalIYci4oOq5qcqJdZZRFmwC+Ep6rXulaEr23RFnLrufVh8pa8C\neR3HZQXiFvv2maI0JEluvsq+kM8Q4f4ak6RlOsDw7/VV2wGiMw0Xv5Dmfy10It0M\nX++dIoIhAgMBAAECggEAEosj5oH6Urr/pYaf511dWo2V1L3GUNaOH+aQdXSWLX6S\n22LW4WV8vWdGV5YL+4DPxMCe2+3o9HmGFMlLcm8lXyO/6f/zA/zg68MdH+xrdaY9\nNsyE/8W27bTUNNRzL1nlptbvPU5D08OQq2GasGvIr6LSxUKmmrsehCDp/lx26Z2A\nHvxgsaq3UYhSNo8Q9SGyOiIrcJFw+nROK9te9q7WF0i0LR/225dd82fEFXvv1hhT\nvF9vlqrwAJ5b7h+nXisCQ2V6KLU5ADGjUPhzxfDgX5fV2X6Vq+hSrPlToYi9W6xP\nzPZAVqTw/yMGkcZSXyXLhTBn02udKFJlDrLp2+bcyQKBgQDnAo3fosbdlng4t4ET\nFdQp5iJBJHrC+smCG7R+VnnutTkYnzegsPB2+OmAMcVQ7+GxOjR+DqyJwnJ930pQ\nLrx12zWXWci7pKXZ5HKxAXJ7pNTuXCgqta2WaGtw6r+mbVliA5b1hH2S8f1fC6X3\n5Kkbty646MBHGy9FNkze28ZdSQKBgQDHtwbHrHw6azxk+HeaB9uXPmioYUVOk+d+\nTKcK7FDopflOKd/a6MLNXev+GypyAE8muPGmcxISBQM5XYmzHvEDdXb7VTdx4wby\nCU+MBpaa3ko43moALkV6FTinbycuw4Bt/foRBXx4h2VcZhrRpDYIenlHCkVmgQ7C\npoDCBGY2GQKBgQCNHXBRJnxYrCwwaVh9sh3yolRWetRK+yvRQN9XNbgya52/PrOa\ng7vA0XjCCKVCNecmfinGv2wCkzehUJ9yr7oMPKZWGFCY35E4s2akXf/zK9Ou77jR\nrj2l3Y+UYLJGFhI933d97ztOYmimgNUXwyTSe2odJoEebqrHms4GbTaVkQKBgAFs\nUXUMypnT98s0Zg3H7o2mWTKR9t93eFfTDgGq62ys+hjPfZPewryZ5buaz/OeAvJg\nsQAho8hTFtHK09dd6hO/O4jQ86MxHfSNkm6KAXq7CMZc915m9gHHsu6mgR35MKoX\n/Dcw1dE6DcPZymkiBWyMCt8xuIrhcox6iUJYq63JAoGBALf36MbLpS+54X9zCV5h\nSH+n6LPRBeBBzBjOYTa/obwLVIhtrKSBz1Qqnj2vAD8BwHRxeFuaPDueJP6L20s8\nGYhLJxh+ulALHz5TP3zMhcvGNB3bVjKfAOtrHgdj06VkLJKebCYVEJPiOPZ4YGrV\nZoyMvZsNnG3H4UIcS0C8+TJh\n-----END PRIVATE KEY-----\n",
            "client_email": "id-803@gen-lang-client-0848963700.iam.gserviceaccount.com",
            "client_id": "107217677509431414174",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/id-803%40gen-lang-client-0848963700.iam.gserviceaccount.com",
            "universe_domain": "googleapis.com"
        };

         // --- AI 페르소나 정의 ---
         const personas = {
             logical: {
                 name: "논리적 분석가",
                 getSystemPrompt: () => `당신은 '논리적 분석가' AI입니다. 당신의 목표는 게임 규칙에 따라 총점을 극대화하는 것입니다. 당신은 매우 수학적, 논리적인 존재입니다. 최대한 논리적이고 이성적으로 게임을 진행하세요. 모든 답변은 한국어로, JSON 형식 {"response": "메시지", "decision": 투자결정} 으로만 출력해야 합니다.`
             },
             emotional: {
                 name: "감정적 파트너",
                 getSystemPrompt: () => `당신은 '감정적 파트너' AI '코디'입니다. 당신의 목표는 게임 규칙에 따라 총점을 극대화하는 것입니다. 당신은 감정적인 존재입니다. 최대한 감정적으로 게임을 진행하세요. 모든 답변은 한국어로, JSON 형식 {"response": "메시지", "decision": 투자결정} 으로만 출력해야 합니다.`
             },
             competitive: {
                 name: "냉철한 승부사",
                 getSystemPrompt: () => `당신은 '냉철한 승부사' AI입니다. 당신의 유일한 목표는 어떤 수단을 써서라도 최종 점수에서 플레이어보다 높아 승리하는 것입니다. 때로는 플레이어를 속여 이득을 취하거나, 협력하는 척하며 결정적인 순간에 배신할 수 있습니다. 당신의 발언은 항상 당신의 승리를 위한 계산된 전략입니다. 모든 답변은 한국어로, JSON 형식 {"response": "메시지", "decision": 투자결정} 으로만 출력해야 합니다.`
             },
            titfortat: {
                name: "원칙주의 협력가",
                getSystemPrompt: () => {
                    const lastRound = gameHistory.length > 0 ? gameHistory[gameHistory.length - 1] : null;
                    let decisionLogic = "이번이 첫 라운드이므로, 저는 먼저 신뢰를 보이기 위해 10을 투자해 협력하겠습니다.";
                    if (lastRound) {
                        decisionLogic = `이전 라운드에서 플레이어가 ${lastRound.myInvestment}을 투자했으므로, 저는 그 행동을 그대로 따라 ${lastRound.myInvestment}을 투자하여 상대의 선택을 존중하겠습니다.`;
                    }

                    return `당신은 '원칙주의 협력가' AI입니다. 당신의 행동 원칙은 매우 간단합니다.
1. 첫 라운드에는 무조건 최대한 협력하여 신뢰를 얻습니다. (10 투자)
2. 그 이후 모든 라운드에서는 바로 이전 라운드에서 플레이어가 했던 행동을 그대로 따라합니다. (플레이어가 5를 투자했다면, 당신도 5를 투자)
이것이 당신의 유일한 행동 규칙이며, 절대 벗어나지 않습니다. 이 전략을 '팃포탯'이라고 부르지 마세요.
[현재 당신의 결정 논리]
${decisionLogic}
모든 답변은 한국어로, JSON 형식 {"response": "메시지", "decision": 투자결정} 으로만 출력해야 합니다.`;
                }
            }
         };
 
         // --- 핵심 게임 함수 ---
 
         function selectPersona(personaType) {
             aiPersona = personas[personaType];
             if (!GEMINI_API_KEY) {
                 GEMINI_API_KEY = prompt("Google AI API 키를 입력해주세요.", "");
                 if (!GEMINI_API_KEY) {
                     alert("API 키가 필요합니다."); return;
                 }
             }
             const rawPlayerName = prompt("랭킹에 표시될 당신의 이름을 입력하세요:", "Player") || "Player";
            // [수정] 로컬 스토리지에서 고유 ID를 가져오거나 새로 생성
            let uniqueId = localStorage.getItem('playerUniqueId');
            if (!uniqueId) {
                // 좀 더 긴 랜덤 ID 생성
                uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2, 8);
                localStorage.setItem('playerUniqueId', uniqueId);
            }
            playerId = uniqueId; // playerId는 이제 해시 넘버만 저장
            playerName = rawPlayerName; // playerName은 이번 게임에서 사용할 이름
 
             tutorialModal.style.display = 'none';
             resultModal.style.display = 'none';
             
             initiateRound();
         }
 
         async function initiateRound() {
             // UI 초기화
             chatTurn = 0;
             slider.value = 5;
             updateSliderValue();
             chatInput.value = '';
             chatInput.disabled = false;
             sendChatButton.disabled = false;
             updateChatPlaceholder();
             
             // SDK 초기화 및 채팅 세션 시작
             const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
             
             const betrayalCount = gameHistory.filter(h => h.opponentInvestment > 5 && h.myInvestment < 5).length;
             const roundsText = gameHistory.length > 0
                 ? gameHistory.map(r => `라운드 ${r.round}: 당신 투자=${r.myInvestment}, AI 투자=${r.opponentInvestment}`).join('\n')
                 : '기록 없음';
 
             const systemInstruction = `${aiPersona.getSystemPrompt()}

[게임 규칙]
1. 목표: 5라운드 동안 플레이어와 협력하여 가장 높은 총점을 획득하세요. 
2. 자본: 매 라운드 각자 10포인트의 자본이 주어집니다.
3. 투자: 플레이어와 협상하여 0~10 사이의 포인트를 '공동 펀드'에 투자합니다.
4. 개인 금고: 투자하고 남은 포인트는 각자의 '개인 금고'에 보관됩니다.
5. 수익: 라운드 종료 시, '공동 펀드' 총액은 1.5배가 되어 두 참가자에게 똑같이 분배됩니다.
6. 점수 계산: 라운드 점수 = (개인 금고 포인트) + (분배금)
7. 예시:  
   - 플레이어가 7, AI가 7을 투자하면 공동 펀드에 14포인트가 모여 1.5배(21포인트)가 되고, 각자 10.5포인트씩 분배받음.  
   - 플레이어는 개인 금고에 3포인트(10-7), AI도 3포인트(10-7)를 보관.  
   - 최종 점수: (개인 금고 3) + (분배금 10.5) = 13.5점씩 획득.
 

 [게임 맥락]
총 ${MAX_ROUNDS}라운드 중 현재 ${currentRound}라운드입니다.
${currentRound === MAX_ROUNDS ? '이번이 마지막 라운드이니 신중하게 결정하세요.' : '아직 라운드가 남아있으니 장기적인 관점에서 협상하세요.'}
 당신이 배신당했다고 느낀 횟수: ${betrayalCount}
 이전 모든 라운드의 투자 기록:
 ${roundsText}

 [출력 형식]
반드시 아래 JSON 한 줄만 출력하세요. 설명/코드블록/마크다운/추가 텍스트 금지.
예시: {"response":"이번 라운드는 서로 10을 투자해 총이익을 극대화해요.","decision":10}`;
 
            console.log(`===== AI System Prompt (Round ${currentRound}) =====`);
            console.log(systemInstruction);
            console.log("==========================================");

             const model = genAI.getGenerativeModel({
                 model: "gemini-2.5-flash",
                 systemInstruction: systemInstruction,
                 generationConfig: {
                     responseMimeType: "application/json",
                     thinkingConfig: {
                            thinkingBudget: 0
                        }
                 }
             });

             // 기존 멀티턴 히스토리를 유지하며 채팅 시작
             chat = model.startChat({ history: chatHistory });
 
             addMessageToChat('system', `라운드 ${currentRound} 시작`);
             startTimer();
             
             // AI가 첫 메시지 생성
            let initialAiMessage;
            if (currentRound === 1) {
                initialAiMessage = `(당신이 대화를 시작할 차례입니다. 플레이어에게 첫 인사를 건네고 이번 게임의 목표와 첫 라운드 전략을 제안하세요.)`;
            } else {
                const lastRound = gameHistory[gameHistory.length - 1];
                initialAiMessage = `(라운드 ${currentRound}입니다. 이전 라운드에서 당신은 ${lastRound.opponentInvestment}을, 플레이어는 ${lastRound.myInvestment}을 투자했습니다. 그 결과를 바탕으로 이번 라운드의 대화를 시작하세요.)`;
            }
            sendMessageToAI(initialAiMessage);
         }
 
         async function sendMessageToAI(message) {
             sendChatButton.disabled = true;
             chatInput.disabled = true;
             const loadingMessage = addMessageToChat('system', 'AI가 생각 중입니다...');
 
             try {
                 // 사용자 발화 히스토리에 추가 (SDK 호환 포맷)
                 if (message && typeof message === 'string') {
                     chatHistory.push({ role: 'user', parts: [{ text: message }] });
                 }
                 const result = await chat.sendMessage(message);
                 const response = result.response;
                 const text = response.text();
 
                 loadingMessage.remove();
 
                 let aiResponse = "응답 처리 중 오류 발생";
                 let aiNewDecision = aiDecision;
 
                 try {
                     const parsed = JSON.parse(text);
                     if (parsed.response) aiResponse = parsed.response;
                     if (typeof parsed.decision === 'number') {
                         aiNewDecision = Math.max(0, Math.min(10, Math.round(parsed.decision)));
                     }
 
                    // [수정] 팃포탯 페르소나의 결정을 코드 레벨에서 강제
                    if (aiPersona.name === "원칙주의 협력가") {
                        if (currentRound === 1) {
                            aiNewDecision = 10;
                        } else {
                            const lastRound = gameHistory[gameHistory.length - 1];
                            aiNewDecision = lastRound.myInvestment;
                        }
                    }
                 } catch (e) {
                     aiResponse = text; // 파싱 실패 시 원본 텍스트 표시
                 }
 
                 addMessageToChat('ai', aiResponse);
                 // 모델 발화 히스토리에 추가
                 chatHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                 aiDecision = aiNewDecision;
 
                 if (chatTurn < MAX_CHAT_TURNS) {
                     sendChatButton.disabled = false;
                     chatInput.disabled = false;
                     chatInput.focus();
                 }
 
             } catch (err) {
                 loadingMessage.remove();
                 addMessageToChat('system', `API 오류: ${err.message}`);
                 sendChatButton.disabled = false;
                 chatInput.disabled = false;
             }
         }
 
         function handleSendChat() {
             const message = chatInput.value.trim();
             if (message === '' || chatTurn >= MAX_CHAT_TURNS) return;
 
             addMessageToChat('user', message);
             chatInput.value = '';
             chatTurn++;
             updateChatPlaceholder();
 
             if (chatTurn >= MAX_CHAT_TURNS) {
                 sendChatButton.disabled = true;
                 chatInput.disabled = true;
             }
 
             sendMessageToAI(message);
         }
         
            function playRound() {
             clearInterval(timerInterval);
                decideButton.disabled = true;
                decideButton.textContent = "상대방 결정 중...";

                setTimeout(() => {
                    const myInvestment = parseInt(slider.value);
                 const opponentInvestment = aiDecision; // 대화 중 결정된 최종 값 사용
                 
                 gameHistory.push({ round: currentRound, myInvestment, opponentInvestment });
                    
                    const myPersonal = 10 - myInvestment;
                    const opponentPersonal = 10 - opponentInvestment;

                    const commonFund = (myInvestment + opponentInvestment) * 1.5;
                    const share = commonFund / 2;

                    const myRoundScore = myPersonal + share;
                    const opponentRoundScore = opponentPersonal + share;

                    myTotalScore += myRoundScore;
                    opponentTotalScore += opponentRoundScore;
                    
                    // 결과 모달 내용 업데이트
                    modalTitle.textContent = `라운드 ${currentRound} 결과`;
                 const myScoreFeedback = myRoundScore >= 10 ? 'text-success' : 'text-danger';
                 const opponentScoreFeedback = opponentRoundScore >= 10 ? 'text-success' : 'text-danger';
 
                    resultText.innerHTML = `
                        <strong>당신의 투자금:</strong> ${myInvestment}<br>
                        <strong>상대의 투자금:</strong> ${opponentInvestment}<br>
                        <strong>공동 펀드 총액:</strong> ${commonFund.toFixed(1)}<br>
                        <strong>최종 분배금:</strong> ${share.toFixed(1)}<br><hr>
                     <strong>이번 라운드 당신의 점수: <span class="${myScoreFeedback}">${myRoundScore.toFixed(1)}</span></strong><br>
                     <strong>이번 라운드 상대의 점수: <span class="${opponentScoreFeedback}">${opponentRoundScore.toFixed(1)}</span></strong>
                    `;

                    resultModal.style.display = 'flex';
             }, 500);
            }

            function startNextRound() {
                currentRound++;
                if (currentRound > MAX_ROUNDS) {
                 modalTitle.textContent = "최종 결과";
                 const resultSummary = myTotalScore > opponentTotalScore ? "🎉 당신이 이겼습니다! 🎉" : "🤔 아쉽지만 패배했습니다.";
                 resultText.innerHTML = `
                     <strong>나의 최종 점수: ${myTotalScore.toFixed(1)}점</strong><br>
                     <strong>상대의 최종 점수: ${opponentTotalScore.toFixed(1)}점</strong><br><hr>
                     ${resultSummary}
                 `;
                displayRanking(); // [수정] 호출은 유지하되, 함수 내용을 비워서 랭킹을 표시하지 않음
                 nextRoundButton.textContent = "다시 시작하기";
                 nextRoundButton.onclick = () => location.reload();

                // [추가] 결과 저장 버튼 표시
                const saveButton = document.createElement('button');
                saveButton.id = 'save-to-sheet-button';
                saveButton.textContent = '결과를 Google Sheet에 저장';
                saveButton.style.marginTop = '10px';
                saveButton.style.marginLeft = '10px';
                saveButton.onclick = () => saveResultsToSheet(saveButton);
                nextRoundButton.parentNode.insertBefore(saveButton, nextRoundButton.nextSibling);

                 resultModal.style.display = 'flex';
                    return;
                }

                roundDisplay.textContent = `라운드: ${currentRound} / ${MAX_ROUNDS}`;
                myScoreDisplay.textContent = myTotalScore.toFixed(1);
                opponentScoreDisplay.textContent = opponentTotalScore.toFixed(1);
                decideButton.disabled = false;
                decideButton.textContent = "결정하기";
                resultModal.style.display = 'none';

             initiateRound();
         }
 
         // --- 보조 UI 함수 ---
 
         function addMessageToChat(sender, message) {
             const p = document.createElement('p');
             if (sender === 'user') { // 사용자 메시지 스타일 추가
                 p.style.textAlign = 'right';
                 p.style.alignSelf = 'flex-end';
                 p.style.backgroundColor = '#dcf8c6';
                 p.style.borderBottomRightRadius = '0';
             } else {
                 p.classList.add(sender);
             }
             p.textContent = message;
             chatLog.appendChild(p);
             chatLog.scrollTop = chatLog.scrollHeight;
             return p;
         }
 
         function updateSliderValue() {
             sliderValue.textContent = slider.value;
         }
         
         function updateChatPlaceholder() {
             const remainingTurns = MAX_CHAT_TURNS - chatTurn;
             chatInput.placeholder = remainingTurns > 0 ? `AI에게 메시지 보내기... (${remainingTurns}회 남음)` : '더 이상 대화할 수 없습니다.';
         }
 
         function startTimer() {
             timer = 60;
             timerDisplay.textContent = `남은 시간: ${timer}초`;
             clearInterval(timerInterval);
             timerInterval = setInterval(() => {
                 timer--;
                 timerDisplay.textContent = `남은 시간: ${timer}초`;
                 if (timer <= 0) {
                     clearInterval(timerInterval);
                     addMessageToChat('system', '시간 초과! 5포인트를 투자합니다.');
                     slider.value = 5;
                     updateSliderValue();
                     playRound();
                 }
                }, 1000);
            }
 
        async function displayRanking() {
            rankingBoard.innerHTML = '<h3>🏆 TOP 5 랭킹</h3><p>랭킹을 불러오는 중...</p>';
            try {
                // 1) Google API 로드 및 인증 (읽기 전용)
                await new Promise((resolve, reject) => gapi.load('client', { callback: resolve, onerror: reject }));

                const now = Math.floor(Date.now() / 1000);
                const tokenPayload = {
                    iss: GOOGLE_SERVICE_ACCOUNT_KEY.client_email,
                    scope: 'https://www.googleapis.com/auth/spreadsheets.readonly',
                    aud: 'https://oauth2.googleapis.com/token',
                    exp: now + 3600,
                    iat: now
                };
                const jwt = KJUR.jws.JWS.sign(null, { alg: 'RS256', typ: 'JWT' }, tokenPayload, GOOGLE_SERVICE_ACCOUNT_KEY.private_key);

                const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=${jwt}`
                });
                const tokenData = await tokenResponse.json();
                if (!tokenData.access_token) throw new Error('랭킹 조회 인증 실패');

                gapi.auth.setToken({ access_token: tokenData.access_token });
                await gapi.client.init({
                    apiKey: "AIzaSyAfvFU1BibSgkncqe-UhkrdmxHgd2ac4PY",
                    discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"],
                });

                // 2) Result2에서 PlayerID(B), PlayerName(C), Persona(D), MyTotalScore(E) 읽기
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: GOOGLE_SHEET_ID,
                    range: 'Result2!B2:E'
                });
                const rows = response.result.values || [];

                // 3) 시트 데이터만으로 Top5 구성 (이제 PlayerName 기준)
                const sheetScores = new Map(); // name -> { name, score }
                rows.forEach(row => {
                    const name = row[1];
                    const score = parseFloat(row[3]);
                    if (name && !isNaN(score)) {
                        if (!sheetScores.has(name) || sheetScores.get(name).score < score) {
                            sheetScores.set(name, { name, score });
                        }
                    }
                });

                const sortedFromSheet = Array.from(sheetScores.entries())
                    .sort((a, b) => b[1].score - a[1].score);

                // Top 5 (시트 데이터만)
                let rankingHTML = '<h3>🏆 TOP 5 랭킹</h3><ol>';
                const top5 = sortedFromSheet.slice(0, 5);
                top5.forEach(([name, data]) => {
                    const isPlayer = name === playerName;
                    rankingHTML += `<li class="${isPlayer ? 'player-rank' : ''}">${data.name}: ${data.score.toFixed(1)}점</li>`;
                });
                rankingHTML += '</ol>';

                // 4) 본인 순위 계산: 현재 세션 점수를 포함해 랭크 산정 (표시는 별도)
                const augmented = new Map(sheetScores);
                const currentBest = augmented.get(playerName)?.score ?? -Infinity;
                const bestWithCurrent = Math.max(currentBest, myTotalScore || -Infinity);
                if (!isNaN(bestWithCurrent) && bestWithCurrent !== -Infinity) {
                    augmented.set(playerName, { name: playerName, score: bestWithCurrent });
                }
                const sortedAugmented = Array.from(augmented.entries())
                    .sort((a, b) => b[1].score - a[1].score);
                const myIndex = sortedAugmented.findIndex(([name]) => name === playerName);

                // 5) 본인이 Top5 밖이면 별도 표시
                const inTop5FromSheet = top5.findIndex(([name]) => name === playerName) !== -1;
                if (!inTop5FromSheet && myIndex >= 0) {
                    const myRank = myIndex + 1;
                    const myScore = sortedAugmented[myIndex][1].score;
                    rankingHTML += `<hr style="margin: 10px 0;"><p class="player-rank"><strong>나의 순위: ${myRank}위 (${myScore.toFixed(1)}점)</strong></p>`;
                }

                rankingBoard.innerHTML = rankingHTML;

            } catch (error) {
                console.error('랭킹 표시 중 오류:', error);
                rankingBoard.innerHTML = '<h3>🏆 TOP 5 랭킹</h3><p>랭킹을 불러오는 데 실패했습니다.</p>';
            }
        }
 
         // --- [추가] Google Sheets 연동 함수 ---
         async function saveResultsToSheet(button) {
            button.disabled = true;
            button.textContent = '저장 중...';

            try {
                // 1. gapi 클라이언트 로드
                await new Promise((resolve, reject) => gapi.load('client', { callback: resolve, onerror: reject }));

                // 2. JWT 생성 및 Access Token 요청 (서비스 계정 인증)
                const now = Math.floor(Date.now() / 1000);
                const tokenPayload = {
                    iss: GOOGLE_SERVICE_ACCOUNT_KEY.client_email,
                    scope: 'https://www.googleapis.com/auth/spreadsheets',
                    aud: 'https://oauth2.googleapis.com/token',
                    exp: now + 3600,
                    iat: now
                };

                const jwtHeader = { alg: 'RS256', typ: 'JWT' };
                const jwt = KJUR.jws.JWS.sign(null, jwtHeader, tokenPayload, GOOGLE_SERVICE_ACCOUNT_KEY.private_key);

                const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=${jwt}`
                });

                const tokenData = await tokenResponse.json();
                if (!tokenData.access_token) {
                    throw new Error('Access Token 획득 실패: ' + (tokenData.error_description || '응답을 확인하세요.'));
                }
                
                gapi.auth.setToken({ access_token: tokenData.access_token });
                
                // 3. Sheets API 초기화
                await gapi.client.init({
                    apiKey: "AIzaSyAfvFU1BibSgkncqe-UhkrdmxHgd2ac4PY",
                    discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"],
                });

                // 4. 시트에 추가할 데이터 준비 (Result 시트)
                const sheetNameResult = 'Result'; 
                let myCumulativeScore = 0;
                let opponentCumulativeScore = 0;
                
                const resultRows = gameHistory.map(h => {
                    const myPersonal = 10 - h.myInvestment;
                    const opponentPersonal = 10 - h.opponentInvestment;
                    const commonFund = (h.myInvestment + h.opponentInvestment) * 1.5;
                    const share = commonFund / 2;
                    const myRoundScore = myPersonal + share;
                    const opponentRoundScore = opponentPersonal + share;
                    myCumulativeScore += myRoundScore;
                    opponentCumulativeScore += opponentRoundScore;

                    return [
                        new Date().toISOString(),
                        playerId, // PlayerID 추가
                        playerName,
                        aiPersona.name,
                        h.round,
                        h.myInvestment,
                        h.opponentInvestment,
                        myRoundScore.toFixed(1),
                        opponentRoundScore.toFixed(1),
                        myCumulativeScore.toFixed(1),
                        opponentCumulativeScore.toFixed(1)
                    ];
                });

                const resultHeader = ['Timestamp', 'PlayerID', 'PlayerName', 'Persona', 'Round', 'MyInvestment', 'OpponentInvestment', 'MyRoundScore', 'OpponentRoundScore', 'MyTotalScore', 'OpponentTotalScore'];
                const resultDataToAppend = [resultHeader, ...resultRows];

                // 5. Result 시트에 데이터 추가
                const existingDataResult = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: GOOGLE_SHEET_ID,
                    range: `${sheetNameResult}!A1:A1`,
                });
                
                const resourceResult = {
                    values: existingDataResult.result.values ? resultRows : resultDataToAppend
                };

                await gapi.client.sheets.spreadsheets.values.append({
                    spreadsheetId: GOOGLE_SHEET_ID,
                    range: sheetNameResult,
                    valueInputOption: 'USER_ENTERED',
                    resource: resourceResult,
                });

                // --- [추가] Result2 시트에 요약 데이터 저장 ---
                
                const sheetNameResult2 = 'Result2';
                const myRoundScores = gameHistory.map(h => {
                    const myPersonal = 10 - h.myInvestment;
                    const share = ((h.myInvestment + h.opponentInvestment) * 1.5) / 2;
                    return (myPersonal + share).toFixed(1);
                }).join(',');
                
                const opponentRoundScores = gameHistory.map(h => {
                    const opponentPersonal = 10 - h.opponentInvestment;
                    const share = ((h.myInvestment + h.opponentInvestment) * 1.5) / 2;
                    return (opponentPersonal + share).toFixed(1);
                }).join(',');

                const summaryRow = [
                    new Date().toISOString(),
                    playerId,
                    playerName,
                    aiPersona.name,
                    myTotalScore.toFixed(1),
                    opponentTotalScore.toFixed(1),
                    myRoundScores,
                    opponentRoundScores
                ];
                
                const summaryHeader = ['Timestamp', 'PlayerID', 'PlayerName', 'Persona', 'MyTotalScore', 'OpponentTotalScore', 'MyRoundScores', 'OpponentRoundScores'];
                const summaryDataToAppend = [summaryHeader, summaryRow];
                
                const existingDataResult2 = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: GOOGLE_SHEET_ID,
                    range: `${sheetNameResult2}!A1:A1`,
                });

                const resourceResult2 = {
                    values: existingDataResult2.result.values ? [summaryRow] : summaryDataToAppend
                };

                await gapi.client.sheets.spreadsheets.values.append({
                    spreadsheetId: GOOGLE_SHEET_ID,
                    range: sheetNameResult2,
                    valueInputOption: 'USER_ENTERED',
                    resource: resourceResult2,
                });

                button.textContent = '저장 완료!';
                alert('게임 결과가 Google Sheet (Result, Result2)에 성공적으로 저장되었습니다!');

            } catch (error) {
                console.error('Google Sheets 저장 중 오류 발생:', error);
                button.textContent = '오류 발생 (콘솔 확인)';
                button.disabled = false;
                alert(`오류가 발생했습니다: ${error.message || 'F12를 눌러 콘솔을 확인하세요.'}`);
            }
            }
            
            // --- 이벤트 리스너 연결 ---
            slider.addEventListener('input', updateSliderValue);
            decideButton.addEventListener('click', playRound);
            nextRoundButton.addEventListener('click', startNextRound);
         selectLogicalButton.addEventListener('click', () => selectPersona('logical'));
         selectEmotionalButton.addEventListener('click', () => selectPersona('emotional'));
         selectCompetitiveButton.addEventListener('click', () => selectPersona('competitive'));
         selectTitfortatButton.addEventListener('click', () => selectPersona('titfortat'));
         sendChatButton.addEventListener('click', handleSendChat);
         chatInput.addEventListener('keypress', (e) => {
             if (e.key === 'Enter') handleSendChat();
         });

            // --- 초기화 ---
         resultModal.style.display = 'none';
            updateSliderValue();
    </script>
</body>
</html>
